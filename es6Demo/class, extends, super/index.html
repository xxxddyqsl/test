<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>class, extends, super</title>
</head>
<body>
    <button onclick='replaceTemplate("contact-form-7" ,"619" ,"Contact form 1")'>
		[contact-form-7 id="619" title="Contact form 1"]
	</button>
</body>
<script>
    function replaceTemplate(contact,id,type){
		var val='['+contact+' id="'+id+'" title="'+type+'"]';
		// var f=`<?php echo do_shortcode('[contact-form-7 id="2406" title="form 2"]'); ?>`;
        var f=`<?php echo do_shortcode(${val}); ?>`;
		console.log(f)
        var f=`<?php echo do_shortcode('['+contact+' id="'+id+'" title="'+type+'"]'); ?>`;
	}
    // class, extends, super 这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承
    // class定义了一个“类” ( Animal )
    class Animal {
        // constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的
        constructor(){
            this.type = 'animal'
        };
        says(say){
            console.log('type:' + this.type + ' say: '+ say);
        };
    }
    let animal=new Animal();
    animal.says('hello');//type:animal say: hello
 
    // 定义了一个Cat类，该类通过 extends 关键字，继承了Animal类的所有属性和方法。 Cat类 是 Animal类的 子类
    class Cat extends Animal{
        constructor(){
            // super() 关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
            // ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
            super();
            this.type = 'Cat';
        }
    }
    let cat = new Cat();
    cat.says('Cat类 是 Animal类的 子类');
</script>
</html>