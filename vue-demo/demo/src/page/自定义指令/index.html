<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue入门之自定义指令</title>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>

<body>
  <!-- 自定义指令
vue中的自定义指令通过Vue.directive来实现，主要完成内置指令不能完成的一些事情 -->
<!-- 自定义指令解决的问题或者说使用场景是对普通 DOM 元素进行底层操作，所以不能盲目的胡乱的使用自定义指令。 -->
  <div id="app">
    <!-- 自定义 指令 v-test -->
    <div v-test="color">
      {{num}}
    </div>
    <button onclick="unbindApp()">解绑</button>

    <ul>
      <li v-for="(item,index) in arr" :key="index" v-myclick="item">{{item}}</li>
  </ul>
  </div>
</body>
<script>
  // 解绑
  function unbindApp() {
    app.$destroy();
  }
  // 自定义指令 局部指令的创建。
  let Opt = {
    bind:function(el,binding,vnode){ 
        /** el可以获取当前dom节点，并且进行编译，也可以操作事件 **/
            /** binding指的是一个对象，一般不用 **/
            /** vnode 是 Vue 编译生成的虚拟节点 **/
      // app.arr[5]='pp' 未更新列表数据
      el.addEventListener('click',function(){
            console.log(el, binding.value)
        })
    },
    inserted:function(el,binding,vnode){
      console.log("2-inserted myclick指令 被插入");
     },
    update:function(el,binding,vnode){
      console.log("3-update myclick指令 更新");
     },
    componentUpdated:function(el,binding,vnode){
      console.log("4-componentUpdated  myclick指令 更新完成");
     },
    unbind:function(el,binding,vnode){ console.log("5-unbind myclick指令 解绑"); },
}
// 对于局部组件，我们需要在组件的钩子函数directives中进行声明
// Directives: {
//     Test:     Opt
// }
  // 对于全局自定义指令的创建，我们需要使用 Vue.directive接口
  // Vue.directive('test', Opt)
  //1· 自定义指令 
  Vue.directive('test', {
    //1-被绑定 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作
    bind: function (el, binding, vnode) {
      console.log("1-bind 被绑定");
      console.log("el:", el);
      console.log("binding:", binding);
      console.log("vnode:", vnode);
      // 参数 color 在app 实例 data 中有声明
      let key=binding.expression;
      // 参数 color 的值 red
      let val= binding.value;
      console.log(key,val);
      // el.style."+key+"= val; 
      // JS创建的style样式使用变量
      el.setAttribute("style",key+":"+ val+";"+"border:1px solid "+val+";");
    },
    //2-被插入 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）
    inserted: function (el, binding, vnode) {
      console.log("2-inserted 被插入");
    },
    //3-更新 被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新
    update: function (el, binding, vnode) {
      console.log("3-update 更新");
    },
    //4-更新完成 被绑定元素所在模板完成一次更新周期时调用
    componentUpdated: function (el, binding, vnode) {
      console.log("4-componentUpdated 更新完成");
    },
    //5-解绑 只调用一次，指令与元素解绑时调用
    unbind: function (el, binding, vnode) {
      console.log("5-unbind 解绑");
    }
  })
  var app = new Vue({
    el: '#app',
    data: {
      num: 123,
      color: 'red',
      arr:[1,2,3,4,5,6]
    },
    // 存方法的地方
    methods: {

    },
    directives:{   //自定义指令 ⬅⬅⬅ 局部指令的创建。
      myclick:Opt,
    }
  })

//   2、调试步骤
// （1）chrome打开控制器查看
// （2）控制台输入“app.num=’通过控制台设置的新name’”
// （3）点击解绑按钮

// 3、参数说明
// el：指令所绑定的元素，可以用来直接操作DOM
// binding： 一个对象，包含指令的很多信息
// vnode:：Vue编译生成的虚拟节点
// 4、生命周期
// 自定义指令有五个生命周期（也叫钩子函数），分别是bind、inserted、update、componentUpdated、unbind，说明如下：

// bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作
// inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）
// update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新
// componentUpdated：被绑定元素所在模板完成一次更新周期时调用
// unbind：只调用一次，指令与元素解绑时调用
</script>

</html>