{"version":3,"file":"bundle.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;ACTA,qCAAqC;AACrC,MAAM,UAAU;IACZ,6DAA6D;IAC7D,MAAM,CAAC,WAAW;QACd,IAAI,UAAU,CAAC,SAAS,IAAI,IAAI,EAAE;YAC9B,KAAK,CAAC,QAAQ,CAAC;YACf,UAAU,CAAC,SAAS,GAAG,IAAI,UAAU,EAAE,CAAC;SAC3C;QACD,OAAO,UAAU,CAAC,SAAS,CAAC;IAChC,CAAC;IAGD,GAAG,CAAE,CAAQ,EAAC,CAAQ;QAClB,OAAO,OAAO,CAAC,GAAG,CAAC,YAAY,EAAC,CAAC,GAAC,CAAC,CAAC,CAAC;IACzC,CAAC;IACD,OAAO,CAAC,CAAQ;QACZ,OAAO,IAAI,CAAC,IAAI,GAAC,CAAC,CAAC;IACvB,CAAC;;AACc,oBAAS,GAAgB,IAAI,CAAC,CAAC,6BAA6B;AAE/E,wBAAwB;AACxB,SAAgB,YAAY;IACxB,2JAA2J;IAC3J,OAAO,UAAU,CAAC,WAAW,EAAE,CAAC;AACpC,CAAC;AAHD,oCAGC;;;;;;;UCzBD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;;;ACrBA,wEAA+C;AAS/C,SAAgB,aAAa;IACzB,OAAO,wBAAI,GAAE,CAAC;AAClB,CAAC;AAFD,sCAEC","sources":["webpack://finalModule/webpack/universalModuleDefinition","webpack://finalModule/./src/ts/testA.ts","webpack://finalModule/webpack/bootstrap","webpack://finalModule/./src/ts/main.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"finalModule\"] = factory();\n\telse\n\t\troot[\"finalModule\"] = factory();\n})(self, function() {\nreturn ","import * as Main from './main';\r\n//implements关键字代表该类实现该接口，该类必须定义接口中的方法\r\nclass testAPoint implements Main.IPerson {\r\n    // static 关键字 声明静态方法，就表示该方法不会被实例继承，可以直接通过类来调用， 不需要new 获取 类的实例\r\n    static getInstance() : Main.IPerson {\r\n        if (testAPoint._instance == null) {\r\n            alert('new获取类')\r\n            testAPoint._instance = new testAPoint();\r\n        }\r\n        return testAPoint._instance;\r\n    }\r\n    // 必须按照 main 主进程 接口规则\r\n    name: string;\r\n    add (x:number,y:number){\r\n        return console.log('输出add函数==>',x+y);\r\n    }\r\n    setName(n:string){\r\n        return this.name=n;\r\n    }\r\n    private static _instance : testAPoint = null; // 关键字 private 声明私有变量 只能类内部访问\r\n}\r\n// export 导出的东西需要在导入的时候加\r\nexport function NewRtcClient() : Main.IPerson {\r\n    // 调用 testAPoint 类 设置的静态方法 getInstance 判断静态变量_instance 是否已经绑定了 testAPoint 类的实例  没有则 获取testAPoint类的实例 并把testAPoint类的实例绑定在 static 设置的静态变量 _instance 上 来调用内部方法\r\n    return testAPoint.getInstance();\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\r\nimport {NewRtcClient as Impl }  from './testA';\r\n// main 设置  接口\r\nexport interface IPerson {\r\n    name: string;\r\n    // 设置相+ 接口\r\n     add(x:number,y:number):void\r\n    //  设置 name 接口\r\n     setName(n:string):void\r\n}\r\nexport function MakeRtcClient():IPerson {\r\n    return Impl();\r\n}\r\n\r\n"],"names":[],"sourceRoot":""}