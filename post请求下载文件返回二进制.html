<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<script>
    // ie不支持a标签download方式 下载文件兼容ie
    function DownloadFile(url, name) {
        // url ? url : url = '../css/PoDetails.css';
        // name ? name : name = '测试下载';
        if (!url || url == '')
            return alert(window.languageFn('无法下载，文件路径错误'));
        // 下载路径转发 - 测试地址
        // url = '/api' + url;
        maskLayerShow(window.languageFn('正在下载！'));
        //判断是否是IE浏览器，是的话返回true
        if (window.navigator.msSaveOrOpenBlob) {
            console.log('IE浏览器,', url)
            const xhr = new XMLHttpRequest()
            xhr.open('GET', url, true)
            xhr.responseType = 'blob'
            xhr.onload = function () {
                if (this.status === 200) {
                    // 返回200
                    let blob = this.response;
                    try {
                        window.navigator.msSaveOrOpenBlob(blob, name)
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
            xhr.send()
        } else {
            const ele = document.createElement('a');
            ele.setAttribute('href', url);//设置下载文件的文件路径
            ele.setAttribute('download', name);//设置下载文件的文件名称
            ele.click();
        }
        // 删除 蒙层 提示元素
        $('.maskLayer').remove();

    }
    // 该方法是创建下载，上面的jQuery的方法接口访问成功后调用，原生js的方法已在自己方法内部定义过该部分内容
    function downloadFile(res, fileName) { // res为后端传来的文件流，// fileName为文件名称，自己根据实际情况赋值
        let url = window.URL.createObjectURL(res);

        const ele = document.createElement('a');
        ele.setAttribute('href', url);//设置下载文件的文件路径
        ele.setAttribute('download', fileName);//设置下载文件的文件名称
        ele.click();
        window.URL.revokeObjectURL(url) // 释放掉blob对象
    };
    // 方式一 : 使用jq
    function downloadAjax(id) {
        let data = { fileId: id || '9b71ebff-a492-42da-98ea-79a0d8783498' };
        $.ajax({
            url: '/api/FormApplication/IndiEV/SapFormMergeShow.aspx/DownloadFileTest', // url为请求接口连接
            type: 'POST',
            data: JSON.stringify(that.data),
            processData: false,
            //   dataType: 'binary',
            contentType: 'application/json',
            //  xhrFields 属性 定义响应类型为 blob - 接收二进制流
            xhrFields: { responseType: "blob" },
            // responseType: 'arraybuffer',  // 该属性只支持jQuery3.5及以上版本，否则下载下来的文件会是乱码
            // responseType: 'blob', // 与上一行一样，'blob'或者'arraybuffer'两个值都可以,二选一
            success: function (res, status, xhr) {
                // 校验 数据返回 是否是Blob二进制流的实例
                if (!(res instanceof Blob)) {
                    return alert('数据流不正确');
                }
                //    获取 响应标头里返回的 文件名 + 文件后缀
                let filename = decodeURIComponent(xhr.getResponseHeader('Content-Disposition').split('filename=')[1]);
                console.log(filename);
                if (filename != '' && filename != 'undefined') {
                    downloadFile(res, fileName);  // res为后端传来的文件流，// fileName为文件名称
                } else {
                    alert('文件名错误，下载失败！');
                }
            },
            error: function (res) {
                console.log('失败')
            }
        });
    }
    // 方式二 : 使用原生js
    var blob;
    function cs() {
        var xhr = new XMLHttpRequest();
        var url = '/api/FormApplication/IndiEV/SapFormMergeShow.aspx/DownloadFileTest';
        xhr.open("post", url, true); // url为请求接口连接
        xhr.setRequestHeader('Content-type', 'application/json');
        // 'blob'或者'arraybuffer'两个值都可以,二选一
        xhr.responseType = "blob"; // // 'blob'或者'arraybuffer'两个值都可以,二选一 
        xhr.onload = function () {
            if (this.status == 200) {
                // 获取响应标头里返回的 文件名+文件后缀名
                // let Header_filename=xhr.getAllResponseHeaders().split("filename=")[1];
                // 获取 字符串 content-length 之前的字符 去除 换行(\r\n) 解码
                // let filename= decodeURIComponent(Header_filename.split("content-length")[0].replace(/\r\n/g,"").replace("\n",""));
                let filename = decodeURIComponent(xhr.getResponseHeader('Content-Disposition').split('filename=')[1]);
                blob = this.response;
                // 校验 数据返回 是否是Blob二进制流的实例
                if (!(blob instanceof Blob)) {
                    return alert('数据流不正确');
                }
                if (filename != '' && filename != 'undefined') {
                    downloadFile(blob, fileName);  // res为后端传来的文件流，// fileName为文件名称
                } else {
                    alert('文件名错误，下载失败！');
                }
                // var link = document.createElement("a");
                // link.href = window.URL.createObjectURL(blob);
                // link.download = filename;
                // link.click();
            } else {
                console.log("请求错误!");
            }
        };
        xhr.onloadend = function (res) { console.log(res) };
        xhr.send(JSON.stringify({ fileId: '9b71ebff-a492-42da-98ea-79a0d8783498' }));
    }; cs()
</script>

</html>