<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>canvas 缩放平移</title>
    <style>
        #myCanvas {
            margin: 0 auto;
            border: 1px solid;
            background-color: blue;
        }
    </style>
</head>

<body>
    <canvas id="myCanvas" width="500" height="500"></canvas>
</body>
<script>
    var canvas, context;
    // imgScale 放大缩小默认值
    var img, imgX = 0, imgY = 0, imgScale = 1;
    // MINIMUM_SCALE 最小缩放值 
    // dragging 是否开启移动
    // pos 鼠标按下时实际在canvas内 的X Y值对象
    // posl 鼠标移动时实际在canvas内 的X Y值对象
    var MINIMUM_SCALE = 0.5, pos = {}, posl = {}, dragging = false;


    (function int() {
        canvas = document.getElementById('myCanvas'); //画布对象
        context = canvas.getContext('2d');//画布显示二维图片
        loadImg();
        canvasEventsInit();

    })();

    function loadImg() {
        img = new Image();
        img.onload = function () {
            drawImage(); 
        }
        // img.src = 'https://static.zhihu.com/liukanshan/images/comics/bg-89c9bdc3.jpg'; 
        img.src = '../../image/Loading.png';
    }

    function drawImage() {
        // 清空 canvas
        context.clearRect(0, 0, canvas.width, canvas.height);
        // console.log(imgX, imgY)
        // 保证  imgX  在  [img.width*(1-imgScale),0]   区间内
        // if (imgX < img.width * (1 - imgScale)) {
        //     imgX = img.width * (1 - imgScale);
        // }
        // else if(imgX>0 ) {
        //     imgX=0
        // }
        // 保证  imgY   在  [img.height*(1-imgScale),0]   区间内
        // if (imgY < img.height * (1 - imgScale)) {
        //     imgY = img.height * (1 - imgScale);
        // }
        // else if(imgY>0) {
        //     imgY=0
        // }

        //  开启 限制元素移动 x y 超出canvas 容器
        // limitExceeded();

        context.drawImage(
            img, //规定要使用的图像、画布或视频。
            0, 0, //开始剪切的 x 坐标位置。
            img.width, img.height,  //被剪切图像的高度。
            imgX, imgY,//在画布上放置图像的 x 、y坐标位置。
            img.width * imgScale, img.height * imgScale  //要使用的图像的宽度、高度
        );
    }
    // 限制元素移动 x y 超出canvas 容器
    function limitExceeded() {
        // x 轴  最小值 禁止超出canvas 容器
        if (imgX <= 0) {
            imgX = 0
        }
        // x 轴 最大值 禁止超出canvas 容器
        if (imgX + img.width * (imgScale) > canvas.getBoundingClientRect().width + canvas.getBoundingClientRect().left) {
            // (canvas.getBoundingClientRect().width + canvas.getBoundingClientRect().left)  当前canvas容器 X轴 最大值
            // img.width元素自身的初始宽度  * imgScale为放大的倍数 = 实际元素的宽度
            // x 轴 最大移动值 = 当前canvas容器 X轴 最大值 - img元素的宽度
            imgX = (canvas.getBoundingClientRect().width + canvas.getBoundingClientRect().left) - img.width * (imgScale)
        }
        if (imgY <= 0) {
            imgY = 0
        }
        // y 轴  最大值 禁止超出canvas 容器
        if (imgY + img.height * (imgScale) > canvas.getBoundingClientRect().height + canvas.getBoundingClientRect().top) {
            imgY = (canvas.getBoundingClientRect().height + canvas.getBoundingClientRect().top) - img.height * (imgScale)
        }
    }
    /*事件注册*/
    function canvasEventsInit() {
        canvas.onmousedown = function (event) {
            dragging = true;
            pos = windowToCanvas(event.clientX, event.clientY);  //坐标转换，将窗口坐标转换成canvas的坐标
            //  event.clientX 鼠标x 轴 的位置  - canvas自身的偏移量 = 实际鼠标x 轴 在canvas上的位置  
            // canvas.getBoundingClientRect().width = canvas的宽度+边框的宽度   - canvas的宽度/2 = 边框的宽度
            // pos.x = event.clientX -  canvas.getBoundingClientRect().left - (canvas.getBoundingClientRect().width - canvas.width)/2;
            //  event.clientX 鼠标x 轴 的位置  - canvas自身的偏移量 = 实际鼠标x 轴 在canvas上的位置
            // pos.y = event.clientY -  canvas.getBoundingClientRect().top - (canvas.getBoundingClientRect().height - canvas.height)/2;

        };
        canvas.onmousemove = function (evt) {  //移动
            if (dragging) {
                posl = windowToCanvas(evt.clientX, evt.clientY);
                // posl.x 鼠标移动时在 canvas 内的最新实际坐标 -  pos.x 鼠标按下时或者是上一次移动的坐标 在 canvas 内的实际坐标 = 鼠标移动时物体边界距离屏幕边界的距离
                var x = posl.x - pos.x,
                y = posl.y - pos.y;
                // posl.x - pos.x = 当前移动的 x 轴偏移量 - 上次移动或获取的x 轴偏移量 = 当前移动的 x轴移动值
                console.log(x, y);
                // imgX 上次的x轴位置 + 当前偏移的 x轴移动的值 = 当前x 轴的坐标
                imgX += x;
                imgY += y;
                // 深度拷贝 posl 鼠标移动后的xY坐标 实时赋值给 pos 在下次移动时使用
                pos = JSON.parse(JSON.stringify(posl));
                drawImage();  //重新绘制图片
            }

        };
        // 鼠标移出 canvas 禁止 移动
        canvas.onmouseout = function () {
            dragging = false;
        }
        // 鼠标松开 canvas 禁止 移动
        canvas.onmouseup = function () {
            dragging = false;
        };
         //滚轮放大缩小
        canvas.onmousewheel = canvas.onwheel = function (event) {
            //获取当前鼠标在canvas里的 X Y坐标位置
            var pos = windowToCanvas(event.clientX, event.clientY);
            event.wheelDelta = event.wheelDelta ? event.wheelDelta : (event.deltalY * (-40));  //获取当前鼠标的滚动情况
            var newPos = { x: ((pos.x - imgX) / imgScale).toFixed(2), y: ((pos.y - imgY) / imgScale).toFixed(2) };
            if (event.wheelDelta > 0) {// 放大
                imgScale += 0.1;
                imgX = (1 - imgScale) * newPos.x + (pos.x - newPos.x);
                imgY = (1 - imgScale) * newPos.y + (pos.y - newPos.y);
            } else {//  缩小
                imgScale -= 0.1;
                if (imgScale < MINIMUM_SCALE) {//最小缩放1
                    imgScale = MINIMUM_SCALE;
                }
                imgX = (1 - imgScale) * newPos.x + (pos.x - newPos.x);
                imgY = (1 - imgScale) * newPos.y + (pos.y - newPos.y);
                console.log(imgX, imgY);
            }
            drawImage();   //重新绘制图片

        };
    }


    /*坐标转换*/
    function windowToCanvas(x, y) {
        var box = canvas.getBoundingClientRect();  //这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离
        //  event.clientX 鼠标x 轴 的位置  - canvas自身的偏移量 = 实际鼠标x 轴 在canvas上的位置
        // box.width = canvas的宽度+边框的宽度   -  canvas.width /2 = 边框的宽度
        return {
            x: x - box.left - (box.width - canvas.width) / 2,
            y: y - box.top - (box.height - canvas.height) / 2
        };
    }



</script>

</html>